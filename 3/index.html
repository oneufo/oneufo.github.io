<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TREE(3) // Mathematical Infinity Concept</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&family=Space+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #0a0a0a;
            --color-text: #f4f4f4;
            --color-accent: #00e2ac;
            --color-secondary: #ff3a5e;
            --color-tertiary: #7b5afc;
            --font-primary: 'Space Grotesk', sans-serif;
            --font-mono: 'Space Mono', monospace;
            --spacing-unit: clamp(0.75rem, 2vw, 1.25rem);
            --ease: cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            background-color: var(--color-bg);
            color: var(--color-text);
            font-family: var(--font-primary);
            font-weight: 300;
            line-height: 1.6;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        section {
            padding: calc(var(--spacing-unit) * 8) calc(var(--spacing-unit) * 2);
            position: relative;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
        }
        
        .limited-width {
            max-width: 820px;
            margin: 0 auto;
        }
        
        h1, h2, h3, h4 {
            font-weight: 500;
            line-height: 1.2;
        }
        
        h1 {
            font-size: clamp(3rem, 10vw, 6.5rem);
            letter-spacing: -0.03em;
            margin-bottom: calc(var(--spacing-unit) * 3);
            position: relative;
        }
        
        h2 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            letter-spacing: -0.02em;
            margin-bottom: calc(var(--spacing-unit) * 2);
            position: relative;
        }
        
        h3 {
            font-size: clamp(1.25rem, 3vw, 2rem);
            margin-bottom: var(--spacing-unit);
        }
        
        p {
            font-size: clamp(1rem, 1.5vw, 1.2rem);
            margin-bottom: calc(var(--spacing-unit) * 1.5);
            max-width: 70ch;
        }
        
        .accent {
            color: var(--color-accent);
        }
        
        .secondary {
            color: var(--color-secondary);
        }
        
        .tertiary {
            color: var(--color-tertiary);
        }
        
        .mono {
            font-family: var(--font-mono);
        }
        
        /* Header */
        .site-header {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .site-header::after {
            content: "";
            position: absolute;
            width: 120%;
            height: 120%;
            top: -10%;
            left: -10%;
            background: radial-gradient(circle, rgba(10,10,10,0) 0%, var(--color-bg) 70%);
            z-index: 1;
            pointer-events: none;
        }
        
        .hero-text {
            position: relative;
            z-index: 10;
        }
        
        .tag-line {
            font-size: clamp(1.25rem, 2.5vw, 2rem);
            margin-bottom: calc(var(--spacing-unit) * 4);
            max-width: 36ch;
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: calc(var(--spacing-unit) * 2);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.7;
            z-index: 10;
        }
        
        .scroll-indicator span {
            font-size: 0.8rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: var(--spacing-unit);
        }
        
        .scroll-arrow {
            width: 20px;
            height: 40px;
            border: 2px solid var(--color-text);
            border-radius: 10px;
            position: relative;
        }
        
        .scroll-arrow::before {
            content: "";
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background-color: var(--color-text);
            border-radius: 50%;
            animation: scrollDown 2s infinite;
        }
        
        @keyframes scrollDown {
            0% { transform: translate(-50%, 0); opacity: 1; }
            80% { transform: translate(-50%, 15px); opacity: 0; }
            100% { transform: translate(-50%, 0); opacity: 0; }
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Concept Section */
        .concept-section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: calc(var(--spacing-unit) * 2);
            margin-top: calc(var(--spacing-unit) * 4);
        }
        
        .concept-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            padding: calc(var(--spacing-unit) * 2);
            transition: transform 0.3s var(--ease), box-shadow 0.3s var(--ease);
        }
        
        .concept-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .concept-card h3 {
            margin-bottom: calc(var(--spacing-unit) * 1.5);
            position: relative;
            padding-bottom: calc(var(--spacing-unit) * 0.75);
        }
        
        .concept-card h3::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 40px;
            height: 2px;
            background-color: var(--color-accent);
        }
        
        /* Visualization Section */
        .visualization-section {
            padding-top: 0;
        }
        
        .visualization-container {
            position: relative;
            width: 100%;
            height: 80vh;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            overflow: hidden;
            margin-top: calc(var(--spacing-unit) * 4);
        }
        
        .tree-controls {
            position: absolute;
            bottom: var(--spacing-unit);
            left: var(--spacing-unit);
            z-index: 20;
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-unit);
        }
        
        .control-group {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 4px;
            padding: var(--spacing-unit);
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-size: 0.8rem;
            margin-bottom: calc(var(--spacing-unit) * 0.5);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.7;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: calc(var(--spacing-unit) * 0.5);
        }
        
        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--color-accent);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value {
            font-family: var(--font-mono);
            min-width: 30px;
            text-align: right;
        }
        
        button {
            background-color: var(--color-tertiary);
            color: var(--color-text);
            border: none;
            padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit) * 1.5);
            border-radius: 4px;
            font-family: var(--font-primary);
            font-size: 0.9rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background-color 0.2s var(--ease);
        }
        
        button:hover {
            background-color: var(--color-secondary);
        }
        
        /* Comparison Section */
        .comparison-section {
            background: linear-gradient(to bottom, var(--color-bg), rgba(10,10,10,0.97));
        }
        
        .timeline {
            position: relative;
            margin-top: calc(var(--spacing-unit) * 6);
            padding-left: calc(var(--spacing-unit) * 3);
        }
        
        .timeline::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, 
                var(--color-accent), 
                var(--color-tertiary), 
                var(--color-secondary));
        }
        
        .timeline-item {
            position: relative;
            margin-bottom: calc(var(--spacing-unit) * 6);
        }
        
        .timeline-item::before {
            content: "";
            position: absolute;
            left: calc(var(--spacing-unit) * -3);
            top: 0.5rem;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--color-bg);
            border: 2px solid var(--color-accent);
            transform: translateX(-50%);
        }
        
        .timeline-item:nth-child(2)::before {
            border-color: var(--color-tertiary);
        }
        
        .timeline-item:nth-child(3)::before {
            border-color: var(--color-secondary);
        }
        
        .timeline-item h3 {
            display: flex;
            align-items: baseline;
            gap: var(--spacing-unit);
        }
        
        .number-notation {
            font-family: var(--font-mono);
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        /* Footer */
        footer {
            padding: calc(var(--spacing-unit) * 4) var(--spacing-unit);
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.6;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .hero-text {
                padding-left: var(--spacing-unit);
                padding-right: var(--spacing-unit);
            }
            
            .concept-grid {
                grid-template-columns: 1fr;
            }
            
            .visualization-container {
                height: 60vh;
            }
        }
        
        /* Animation classes */
        .fade-in {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 1s var(--ease), transform 1s var(--ease);
        }
        
        .fade-in.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        .stagger-delay-1 { transition-delay: 0.2s; }
        .stagger-delay-2 { transition-delay: 0.4s; }
        .stagger-delay-3 { transition-delay: 0.6s; }
        .stagger-delay-4 { transition-delay: 0.8s; }
        
        /* Hover effect for number spans */
        .number-hover {
            position: relative;
            cursor: pointer;
        }
        
        .number-hover::after {
            content: attr(data-info);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
            background: rgba(0, 0, 0, 0.9);
            padding: var(--spacing-unit);
            border-radius: 4px;
            width: max-content;
            max-width: 300px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 100;
            font-family: var(--font-primary);
            font-weight: 300;
        }
        
        .number-hover:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>
    <header class="site-header">
        <div id="canvas-container"></div>
        <div class="container">
            <div class="hero-text">
                <h1>TREE<span class="accent">(3)</span></h1>
                <p class="tag-line">探索数学世界中最令人震惊的<span class="tertiary">无限大数</span>，超越人类想象的极限。</p>
            </div>
        </div>
        <div class="scroll-indicator">
            <span>探索</span>
            <div class="scroll-arrow"></div>
        </div>
    </header>
    
    <section class="concept-section">
        <div class="container">
            <div class="limited-width">
                <h2 class="fade-in">超越思考的<span class="accent">边界</span></h2>
                <p class="fade-in">TREE(3)是数学领域中一个极其特殊的数字，它源自组合数学与图论，由数学家Harvey Friedman在研究Kruskal树定理时首次引入。这个数字具有一种令人难以置信的特性：它比几乎所有人类曾经构思的数字都要大，大到无法用常规数学符号表示。</p>
                
                <p class="fade-in">在一个充斥着巨大数字的世界里，TREE(3)仍然显得格外特立独行。它不仅是一个数字，更是一个概念边界的象征，展示了有限定义如何产生近乎无限的结果。</p>
            </div>
            
            <div class="concept-grid">
                <div class="concept-card fade-in stagger-delay-1">
                    <h3>定义的<span class="accent">优雅</span></h3>
                    <p>TREE函数与有标记树的序列相关。对于TREE(n)，我们考虑节点最多有n种颜色的所有有限树序列，每个序列中不存在可通过"同色保序嵌入"嵌入到后续树中的树。TREE(n)是此类序列的最大可能长度。</p>
                </div>
                
                <div class="concept-card fade-in stagger-delay-2">
                    <h3>理解<span class="secondary">复杂性</span></h3>
                    <p>即使是TREE(1)和TREE(2)已经是非常大的数字，而TREE(3)则大到远超出了我们所熟悉的几乎所有数学函数。它比Graham数大得多，后者曾被认为是数学中最大的有用数字。</p>
                </div>
                
                <div class="concept-card fade-in stagger-delay-3">
                    <h3>数学<span class="tertiary">意义</span></h3>
                    <p>TREE(3)的存在说明了有限数学系统中潜在的无限复杂性。它与不可计算性、不完备性定理以及快速增长函数层次有着深刻联系，为我们理解数学结构的极限提供了窗口。</p>
                </div>
            </div>
        </div>
    </section>
    
    <section class="visualization-section">
        <div class="container">
            <h2 class="fade-in"><span class="secondary">抽象</span>可视化</h2>
            <p class="fade-in">由于TREE(3)的规模远超我们的直观理解能力，以下呈现的是一个概念性可视化，旨在帮助理解TREE函数所涉及的树结构和嵌入关系。</p>
            
            <div class="visualization-container fade-in">
                <canvas id="treeVisualization"></canvas>
                
                <div class="tree-controls">
                    <div class="control-group">
                        <label>颜色数量</label>
                        <div class="slider-container">
                            <input type="range" min="1" max="5" value="3" class="slider" id="colorSlider">
                            <span class="slider-value" id="colorValue">3</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>树的复杂度</label>
                        <div class="slider-container">
                            <input type="range" min="1" max="5" value="3" class="slider" id="complexitySlider">
                            <span class="slider-value" id="complexityValue">3</span>
                        </div>
                    </div>
                    
                    <button id="regenerateButton">重新生成</button>
                </div>
            </div>
        </div>
    </section>
    
    <section class="comparison-section">
        <div class="container">
            <div class="limited-width">
                <h2 class="fade-in">无限的<span class="tertiary">层次</span></h2>
                <p class="fade-in">要理解TREE(3)的规模，我们需要将其与其他著名的大数进行比较。以下是数学中一些巨大数字的比较，形成了一条通往TREE(3)的道路。</p>
                
                <div class="timeline">
                    <div class="timeline-item fade-in">
                        <h3>googol <span class="number-notation">10<sup>100</sup></span></h3>
                        <p>一个1后面跟着100个零的数字。这个数字大到超过了可观测宇宙中的原子总数，但在TREE(3)面前，它微不足道。</p>
                    </div>
                    
                    <div class="timeline-item fade-in">
                        <h3>googolplex <span class="number-notation">10<sup>10<sup>100</sup></sup></span></h3>
                        <p>一个1后面跟着googol个零的数字。如果要写下这个数字的所有数位，那么纸张将填满整个可观测宇宙，但它与TREE(3)相比仍然微不足道。</p>
                    </div>
                    
                    <div class="timeline-item fade-in">
                        <h3>Graham数 <span class="number-hover" data-info="Graham数是与一个几何问题相关的数，由数学家Ronald Graham在1971年提出。它曾被吉尼斯世界纪录认定为'最大的数字'。">G</span></h3>
                        <p>在TREE(3)被发现之前，Graham数被认为是数学中最大的有实际应用的数字。它大到无法用标准数学符号表示，需要使用特殊的向上箭头符号来定义。</p>
                    </div>
                    
                    <div class="timeline-item fade-in">
                        <h3>TREE(3) <span class="number-hover" data-info="TREE(3)大到什么程度？想象一下：如果将Graham数代入Ackermann函数A(n,n)，得到的结果仍然远小于TREE(3)。">∞?</span></h3>
                        <p>TREE(3)远远超过了上述所有数字。事实上，如果用这些数字作为输入来构造新的超函数，所得结果仍将远小于TREE(3)。它展示了数学中存在着一种惊人的层次结构，每一层都远超前一层。</p>
                    </div>
                </div>
            </div>
        </div>
    </section>
    
    <footer>
        <div class="container">
            <p>&copy; 2025 TREE(3) Concept Exploration</p>
        </div>
    </footer>
    
    <script>
        // Intersection Observer for fade-in animations
        const fadeElements = document.querySelectorAll('.fade-in');
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                    observer.unobserve(entry.target);
                }
            });
        }, {
            threshold: 0.1
        });
        
        fadeElements.forEach(element => {
            observer.observe(element);
        });
        
        // Canvas Animation for the header
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.createElement('canvas');
        canvasContainer.appendChild(canvas);
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        const ctx = canvas.getContext('2d');
        
        // Particle system
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.1;
                this.speed = Math.random() * 0.5 + 0.1;
                this.opacity = Math.random() * 0.5 + 0.1;
                this.directionX = Math.random() * 2 - 1;
                this.directionY = Math.random() * 2 - 1;
            }
            
            update() {
                this.x += this.directionX * this.speed;
                this.y += this.directionY * this.speed;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.reset();
                }
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.fill();
            }
        }
        
        // Create particles
        const particles = [];
        const particleCount = 150;
        
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
        
        // Connection lines
        function drawConnections() {
            for (let i = 0; i < particles.length; i++) {
                for (let j = i; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 100) {
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * (1 - distance/100)})`;
                        ctx.lineWidth = 0.5;
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw particles
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            drawConnections();
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Tree Visualization
        const treeCanvas = document.getElementById('treeVisualization');
        const treeCtx = treeCanvas.getContext('2d');
        
        function resizeTreeCanvas() {
            treeCanvas.width = treeCanvas.parentElement.offsetWidth;
            treeCanvas.height = treeCanvas.parentElement.offsetHeight;
            drawTree();
        }
        
        window.addEventListener('resize', resizeTreeCanvas);
        
        // Initialize tree canvas after a small delay to ensure parent dimensions are set
        setTimeout(resizeTreeCanvas, 100);
        
        // Color slider
        const colorSlider = document.getElementById('colorSlider');
        const colorValue = document.getElementById('colorValue');
        
        colorSlider.addEventListener('input', function() {
            colorValue.textContent = this.value;
            drawTree();
        });
        
        // Complexity slider
        const complexitySlider = document.getElementById('complexitySlider');
        const complexityValue = document.getElementById('complexityValue');
        
        complexitySlider.addEventListener('input', function() {
            complexityValue.textContent = this.value;
            drawTree();
        });
        
        // Regenerate button
        const regenerateButton = document.getElementById('regenerateButton');
        regenerateButton.addEventListener('click', drawTree);
        
        // Tree drawing function
        function drawTree() {
            const colors = [
                '#00e2ac', // Accent
                '#ff3a5e', // Secondary
                '#7b5afc', // Tertiary
                '#f0db4f',
                '#00b4d8'
            ];
            
            const colorCount = parseInt(colorSlider.value);
            const complexity = parseInt(complexitySlider.value);
            
            // Clear canvas
            treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
            
            // Start recursive tree drawing
            const startX = treeCanvas.width / 2;
            const startY = treeCanvas.height * 0.8;
            const startAngle = -Math.PI / 2; // Upward
            const startLength = treeCanvas.height * 0.25;
            
            drawBranch(startX, startY, startLength, startAngle, 0, complexity, colorCount, colors);
            
            // Draw colored nodes representing the tree structure
            drawNodes();
        }
        
        function drawBranch(x, y, length, angle, depth, maxDepth, colorCount, colors) {
            if (depth > maxDepth) return;
            
            // Calculate branch end point
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;
            
            // Draw branch
            treeCtx.beginPath();
            treeCtx.moveTo(x, y);
            treeCtx.lineTo(endX, endY);
            
            // Color based on depth and available colors
            const colorIndex = depth % colorCount;
            treeCtx.strokeStyle = colors[colorIndex];
            
            // Line width decreases with depth
            treeCtx.lineWidth = 3 - depth * 0.4;
            treeCtx.stroke();
            
            // Base case: reached max depth
            if (depth === maxDepth) return;
            
            // Random factor to make tree more natural
            const randomFactor = 0.1 + Math.random() * 0.2;
            
            // Number of branches depends on depth
            const branchCount = Math.min(3, depth + 2);
            
// Recursively draw branches
            for (let i = 0; i < branchCount; i++) {
                const newAngle = angle + (Math.PI * 0.4) * (i / (branchCount - 1) - 0.5) * (1 + randomFactor);
                const newLength = length * (0.6 + randomFactor * 0.1);
                
                drawBranch(
                    endX, 
                    endY, 
                    newLength, 
                    newAngle, 
                    depth + 1, 
                    maxDepth, 
                    colorCount, 
                    colors
                );
            }
        }
        
        // Draw abstract nodes representing the tree structure
        function drawNodes() {
            const complexity = parseInt(complexitySlider.value);
            const colorCount = parseInt(colorSlider.value);
            const colors = [
                '#00e2ac', // Accent
                '#ff3a5e', // Secondary
                '#7b5afc', // Tertiary
                '#f0db4f',
                '#00b4d8'
            ];
            
            // Create an abstract network of nodes
            const nodes = [];
            const connections = [];
            
            // Generate nodes
            const nodeCount = 10 + complexity * 5;
            for (let i = 0; i < nodeCount; i++) {
                // Position nodes in a circular pattern with some randomness
                const angle = (i / nodeCount) * Math.PI * 2;
                const radius = treeCanvas.height * 0.3 * (0.8 + Math.random() * 0.4);
                const x = treeCanvas.width / 2 + Math.cos(angle) * radius;
                const y = treeCanvas.height / 2 + Math.sin(angle) * radius;
                
                nodes.push({
                    x,
                    y,
                    size: 3 + Math.random() * 4,
                    color: colors[i % colorCount]
                });
            }
            
            // Generate connections
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    // Create more connections for higher complexity
                    if (Math.random() < 0.05 + (complexity * 0.03)) {
                        connections.push({
                            from: i,
                            to: j,
                            width: 0.5 + Math.random(),
                            opacity: 0.1 + Math.random() * 0.3
                        });
                    }
                }
            }
            
            // Draw connections
            connections.forEach(conn => {
                const fromNode = nodes[conn.from];
                const toNode = nodes[conn.to];
                
                treeCtx.beginPath();
                treeCtx.moveTo(fromNode.x, fromNode.y);
                treeCtx.lineTo(toNode.x, toNode.y);
                treeCtx.strokeStyle = `rgba(255, 255, 255, ${conn.opacity})`;
                treeCtx.lineWidth = conn.width;
                treeCtx.stroke();
            });
            
            // Draw nodes
            nodes.forEach(node => {
                treeCtx.beginPath();
                treeCtx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
                treeCtx.fillStyle = node.color;
                treeCtx.fill();
                
                // Add glow effect
                treeCtx.beginPath();
                treeCtx.arc(node.x, node.y, node.size * 2, 0, Math.PI * 2);
                const gradient = treeCtx.createRadialGradient(
                    node.x, node.y, node.size,
                    node.x, node.y, node.size * 2
                );
                gradient.addColorStop(0, `${node.color}99`);
                gradient.addColorStop(1, `${node.color}00`);
                treeCtx.fillStyle = gradient;
                treeCtx.fill();
            });
        }
        
        // Initialize tree drawing
        drawTree();
    </script>
</body>
</html>